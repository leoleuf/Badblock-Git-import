package fr.xmalware.teamspeakbot.features;

import java.sql.ResultSet;
import java.util.AbstractMap;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Timer;
import java.util.TimerTask;
import java.util.stream.Collectors;

import com.github.theholywaffle.teamspeak3.TS3Api;
import com.github.theholywaffle.teamspeak3.api.event.ClientMovedEvent;
import com.github.theholywaffle.teamspeak3.api.event.TextMessageEvent;
import com.github.theholywaffle.teamspeak3.api.wrapper.Client;
import com.warrenstrange.googleauth.GoogleAuthenticator;

import fr.xmalware.teamspeakbot.Main;
import fr.xmalware.teamspeakbot.db.BadblockDatabase;
import fr.xmalware.teamspeakbot.db.Request;
import fr.xmalware.teamspeakbot.db.Request.RequestType;
import fr.xmalware.teamspeakbot.utils.Callback;

public class DoubleAuth
{

	private static TS3Api						api	= Main.getTeamSpeak().getApi();

	public static int							doubleAuthChannel	= 812919;
	private static int							homeChannel			= 2;
	private static Map<Integer, Integer[]>		maps = new HashMap<>();
	public static Map<Client, Entry<String, Integer>>			waiting = new HashMap<>();

	private static GoogleAuthenticator			googleAuth			= new GoogleAuthenticator();

	static
	{
		/*GoogleAuthenticatorConfig googleAuthenticatorConfig = new GoogleAuthenticatorConfig();
		googleAuthenticatorConfig.keyRepresentation = KeyRepresentation.BASE64;
		googleAuth = new GoogleAuthenticator(googleAuthenticatorConfig);*/
		// Admin
		maps.put(17, new Integer[] { 319, 430, 92 });
		// Responsable
		maps.put(16, new Integer[] { 293, 430, 104 });
		// Développeur
		maps.put(15, new Integer[] { 123, 430, 370 });
		// Superviseur
		maps.put(14, new Integer[] { 361, 430, 307 });
		// CommunityManager
		maps.put(13, new Integer[] { 314, 430, 320 });
		// Modérateur
		maps.put(12, new Integer[] { 59, 430, 88 });
		// Helper
		maps.put(11, new Integer[] { 59, 352, 430, 87 });
		// Modo-Forum
		maps.put(10, new Integer[] { 126, 430, 287 });
		// Graphiste
		maps.put(9, new Integer[] { 386, 430, 287 });
		// Rédacteur
		maps.put(8, new Integer[] { 126, 430, 287 });
		// Animateur
		maps.put(7, new Integer[] { 68, 430, 85 });
		// Constructeur
		maps.put(6, new Integer[] { 64, 430, 287 });
	}

	public static void onLogin(int clientId, int clientDatabaseId, String uniqueClientIdentifier)
	{
		// Work with double auth of staffs
		/*hasDoubleAuth(clientDatabaseId, uniqueClientIdentifier, new Callback<Entry<String, Integer>>()
		{
			@Override
			public void done(Entry<String, Integer> result, Throwable error)
			{
				// If the custom rank is added, we delete his other ranks
				if (result != null && !result.getKey().isEmpty())
				{
					moveToChannel(clientId, uniqueClientIdentifier, result.getKey(), result.getValue());
				}
			}
		});*/
	}

	private static void hasDoubleAuth(int clientDatabaseId, String uniqueClientIdentifier, Callback<Entry<String, Integer>> callback)
	{
		BadblockDatabase.getInstance().addRequest(new Request("SELECT doubleAuth, rang FROM joueurs WHERE tsid = '" + uniqueClientIdentifier + "'", RequestType.GETTER) {
			@Override
			public void done(ResultSet resultSet) 
			{
				try
				{

					// If the player isn't linked with his TS id
					if (!resultSet.next())
					{
						callback.done(null, null);
						return;
					}

					// Get basic values
					int rank = resultSet.getInt("rang");

					if (rank <= 5)
					{
						callback.done(null, null);
						return;
					}

					String doubleAuth = resultSet.getString("doubleAuth");

					if (doubleAuth == null || doubleAuth.isEmpty())
					{
						Client client = api.getClientByUId(uniqueClientIdentifier);
						api.kickClientFromServer("Vous devez configurer votre double authentification pour vous connecter.", client);
						callback.done(null, null);
						return;
					}

					callback.done(new AbstractMap.SimpleEntry<>(doubleAuth, rank), null);

				}
				catch (Exception error)
				{
					error.printStackTrace();
				}
			}
		});
	}

	public static void onDisconnect(String uniqueClientIdentifier)
	{
		for (Client c : waiting.keySet().stream().filter(c 
				-> c.getUniqueIdentifier().equals(uniqueClientIdentifier)).collect(Collectors.toList()))
		{
			waiting.remove(c);
		}
	}

	private static void moveToChannel(int clientId, String uniqueClientIdentifier, String doubleAuth, int rank)
	{
		Client client = api.getClientInfo(clientId);

		// Unknown client
		if (client == null)
		{
			return;
		}

		// Move client to double auth channel
		api.moveClient(clientId, doubleAuthChannel);

		// Send a message to channel
		api.pokeClient(clientId, client.getNickname() + ", entrez votre code de double authentification dans le t'chat.");		

		long last = System.currentTimeMillis();

		onDisconnect(uniqueClientIdentifier);

		waiting.put(client, new AbstractMap.SimpleEntry<>(doubleAuth, rank));

		// Check
		new Timer().schedule(new TimerTask()
		{
			@Override
			public void run()
			{
				if (waiting.keySet().stream().filter(c 
						-> c.getUniqueIdentifier().equals(uniqueClientIdentifier)).count() < 1)
				{
					cancel();
					return;
				}

				Client client = api.getClientByUId(uniqueClientIdentifier);
				if (client == null)
				{
					waiting.remove(client);
					cancel();
					return;
				}

				long max = 60_000;
				if (System.currentTimeMillis() - max > last)
				{
					api.kickClientFromServer("Vous avez mis trop de temps à vérifier votre identité.", client.getId());
					waiting.remove(client);
					cancel();
					return;
				}
			}
		}, 500, 500);

	}

	public static void onChannelChange(ClientMovedEvent event)
	{
		Optional<Client> optionalClient = waiting.keySet().stream().filter(c 
				-> c.getUniqueIdentifier().equals(event.getInvokerUniqueId())).findFirst();

		if (!optionalClient.isPresent())
		{
			return;
		}

		if (event.getTargetChannelId() != doubleAuthChannel)
		{
			api.kickClientFromServer("Vous devez vous authentifier avant de rejoindre un autre canal.", event.getClientId());
			return;
		}
	}

	public static void onTextMessage(TextMessageEvent event)
	{
		Optional<Client> optionalClient = waiting.keySet().stream().filter(c 
				-> c.getUniqueIdentifier().equals(event.getInvokerUniqueId())).findFirst();
		System.out.println("Received a message from " + event.getInvokerName() + " : " + event.getMessage());
		if (!optionalClient.isPresent())
		{
			return;
		}
		System.out.println("This invoker ID is in a double-auth connection.");

		Client client = optionalClient.get();

		Entry<String, Integer> entry = waiting.get(client);

		String secretCode = entry.getKey();
		int rank = entry.getValue();
		String rawTemporaryCode = event.getMessage();

		int temporaryCode = -1;

		try
		{
			temporaryCode = Integer.parseInt(rawTemporaryCode);
		}
		catch (Exception error)
		{
			api.kickClientFromServer("Code de sécurité invalide.", client.getId());
			waiting.remove(client);
			return;
		}

		if (googleAuth.authorize(secretCode, temporaryCode))
		{
			waiting.remove(client);
			api.moveClient(client.getId(), homeChannel);

			if (maps.containsKey(rank))
			{
				for (int b : maps.get(rank))
				{
					api.addClientToServerGroup(b, client.getDatabaseId());
				}
			}

			api.pokeClient(client.getId(), "Authentification vérifiée.");
		}
		else
		{
			waiting.remove(client);
			api.kickClientFromServer("Code de sécurité invalide.", client.getId());
			return;
		}
	}

}
