package fr.xmalware.badblock.bungeecord.badblockbungeeothers;


import java.io.File;
import java.io.IOException;
import java.lang.reflect.Type;
import java.sql.ResultSet;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;

import com.cloudflare.api.CloudflareAccess;
import com.cloudflare.api.constants.RecordType;
import com.cloudflare.api.requests.dns.DNSAddRecord;
import com.cloudflare.api.requests.dns.DNSDeleteRecord;
import com.cloudflare.api.utils.TimeUnit;
import com.cloudflare.api.utils.TimeUnit.UnitType;
import com.google.gson.reflect.TypeToken;

import fr.badblock.commons.technologies.rabbitmq.RabbitConnector;
import fr.badblock.commons.technologies.rabbitmq.RabbitService;
import fr.badblock.commons.technologies.redis.RedisConnector;
import fr.badblock.commons.technologies.redis.RedisService;
import fr.badblock.commons.utils.Callback;
import fr.badblock.ladder.bungee.LadderBungee;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.commands.BListCommand;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.commands.BOAddInsultCommand;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.commands.BOReloadCommand;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.commands.BORemoveInsultCommand;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.commands.DoneCommand;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.database.BadblockDatabase;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.database.Request;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.database.Request.RequestType;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.listeners.PlayerQuitListener;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.listeners.PreLoginListener;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.logs.filters.IHConnectedFilter;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.logs.filters.IHResetByPeerFilter;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.logs.filters.InjectableFilter;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.modules.BadAdvertsModule;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.modules.BadCommunitySpookerModule;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.modules.BadInsultModule;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.modules.BadPseudoModule;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.modules.GuardianModule;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.modules.PartyChatModule;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.receivers.PlayersUpdateListener;
import lombok.Getter;
import lombok.Setter;
import net.md_5.bungee.BungeeCord;
import net.md_5.bungee.api.ProxyServer;
import net.md_5.bungee.api.plugin.Plugin;
import net.md_5.bungee.api.plugin.PluginManager;
import net.md_5.bungee.config.Configuration;
import net.md_5.bungee.config.ConfigurationProvider;
import net.md_5.bungee.config.YamlConfiguration;
import net.sf.json.JSONObject;

@Getter @Setter public class BadBlockBungeeOthers extends Plugin {

	@Getter @Setter private static BadBlockBungeeOthers instance;

	private Configuration							    configuration;
	private List<InjectableFilter> 						filters 			= new LinkedList<>();
	private RabbitService								rabbitService;
	private	int											players;
	private List<UUID>									reengagedUUIDs;
	private TimerTask									timerTask;
	private TimerTask									timerTask2;
	private boolean										done = false;
	private int											recordId = -1;
	private long										deleteTime = -1;
	private long										connections = -1;
	private RedisService								redisConnector;
	private boolean										finished;
	private long										delete = 10;
	private long										time = 3600;
	public static final Type bungeeDataType 	= new TypeToken<HashMap<String, Bungee>>() {}.getType();
	private CloudflareAccess access;

	@SuppressWarnings("deprecation")
	@Override
	public void onEnable() {
		instance = this;
		reengagedUUIDs = new ArrayList<>();
		ProxyServer proxy = this.getProxy();
		// fichier de config
		try {
			if (!this.getDataFolder().exists()) this.getDataFolder().mkdirs();
			File file = new File(this.getDataFolder(), "config.yml");
			if (!file.exists()) file.createNewFile();
			configuration = ConfigurationProvider.getProvider(YamlConfiguration.class).load(file);
		} catch (IOException e) {
			e.printStackTrace();
		}
		String host = configuration.getString("db.host");
		int port = configuration.getInt("db.port");
		String user = configuration.getString("db.user");
		String pass = configuration.getString("db.pass");
		String db = configuration.getString("db.db");
		BadblockDatabase.getInstance().connect(host, port, user, pass, db);
		access = new CloudflareAccess(configuration.getString("cloudflare.email"), configuration.getString("cloudflare.key"));
		System.out.println(ProxyServer.getInstance().getConfig().getListeners().iterator().next().getHost().getHostString());
		rabbitService = RabbitConnector.getInstance().newService("default", configuration.getString("rabbit.hostname"), configuration.getInt("rabbit.port"), configuration.getString("rabbit.username"),
				configuration.getString("rabbit.password"), configuration.getString("rabbit.virtualhost"));
		redisConnector = RedisConnector.getInstance().newService("default", configuration.getString("redis.hostname"), configuration.getInt("redis.port"), configuration.getString("redis.password"), configuration.getInt("redis.database"));
		new PlayersUpdateListener();
		PluginManager pluginManager = proxy.getPluginManager();
		pluginManager.registerListener(this, new PartyChatModule());
		pluginManager.registerListener(this, new PreLoginListener());
		pluginManager.registerListener(this, new PlayerQuitListener());
		pluginManager.registerListener(this, new BadInsultModule());
		pluginManager.registerListener(this, new BadCommunitySpookerModule());
		pluginManager.registerListener(this, new BadAdvertsModule());
		pluginManager.registerListener(this, new GuardianModule());
		pluginManager.registerListener(this, new BadPseudoModule());
		pluginManager.registerCommand(this, new BOReloadCommand());
		pluginManager.registerCommand(this, new BListCommand());
		pluginManager.registerCommand(this, new DoneCommand());
		//pluginManager.registerCommand(this, new TrackCommand());
		pluginManager.registerCommand(this, new BOAddInsultCommand());
		pluginManager.registerCommand(this, new BORemoveInsultCommand());
		proxy.getPlayers().forEach(player -> Player.get(player));

		filters.clear();
		filters.add(new IHConnectedFilter());
		filters.add(new IHResetByPeerFilter());
		for (InjectableFilter filter : filters) {
			filter.inject();
		}
		proxy.registerChannel("GuardianBroad");
		proxy.registerChannel("GuardianReport");
		proxy.registerChannel("GuardianKick");
		proxy.registerChannel("GuardianBan");
		timerTask2 = new TimerTask() {
			@Override
			public void run() {
				redisConnector.getAsyncObject("bungee_" + configuration.getInt("redis.machineId"), bungeeDataType, new Callback<HashMap<String, Bungee>>() {
					@Override
					public void done(HashMap<String, Bungee> result, Throwable error) {
						String a = ProxyServer.getInstance().getConfig().getListeners().iterator().next().getHost().getHostString() + ":" + ProxyServer.getInstance().getConfig().getListeners().iterator().next().getHost().getPort();
						if (result.containsKey(a)) {
							Bungee bungee = result.get(a);
							if (!finished) {
								bungee.done = done;
								bungee.bungeeTimestamp = System.currentTimeMillis() + 30000;
							}else{
								bungee.done = false;
								bungee.bungeeTimestamp = 0;
							}
						}
						redisConnector.setAsync("bungee_" + configuration.getInt("redis.machineId"), result);
					}
				}, false);
			}
		};
		new Timer().schedule(timerTask2, 1000, 1000);
		new Timer().schedule(new TimerTask() {
			@Override
			public void run() {
				BadblockDatabase database = BadblockDatabase.getInstance();
				database.addRequest(new Request("SELECT pseudo FROM friends ORDER BY id DESC LIMIT 10000;", RequestType.GETTER) {
					@Override
					public void done(ResultSet resultSet) {
						try {
							while (resultSet.next()) {
								String o = resultSet.getString("pseudo");
								if (o != null) {
									if (LadderBungee.getInstance() != null && LadderBungee.getInstance().totalPlayers != null) {
										LadderBungee.getInstance().totalPlayers.add(o);
									}
								}
							}
						}catch(Exception error) {
							error.printStackTrace();
						}
					}
				});
			}
		}, 2500);
		if (configuration.getBoolean("dns")) {
			DNSAddRecord dns = new DNSAddRecord(access, "badblock.fr", RecordType.IPV4Address, "roundrobin.badblock.fr", ProxyServer.getInstance().getConfig().getListeners().iterator().next().getHost().getHostString(), new TimeUnit(UnitType.MINUTES, 2));
			try {
				JSONObject object = dns.executeBasic();
				if (object != null) {
					if (object.has("rec")) {
						JSONObject rec = object.getJSONObject("rec");
						if (rec != null) {
							if (rec.has("obj")) {
								JSONObject obj = rec.getJSONObject("obj");
								if (obj != null) {
									if (obj.has("rec_id")) {
										recordId = obj.getInt("rec_id");
									}
								}
							}
						}
					}
					System.out.println("/!\\ BUNGEEDNS<ADDED/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
				}else System.out.println("/!\\ BUNGEEDNS<NOT-ADDED/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
				dns.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
			System.out.println("RecordID: " + recordId);
			timerTask = new TimerTask() {
				@Override
				public void run() {
					if (done && delete == -1 && BadBlockBungeeOthers.getInstance().getPlayers() <= 0) {
						System.out.println("/!\\ BUNGEEDNS!<EVENT-BYEBUNGEE!/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
						System.exit(-1);
					}else if (done && delete > 0) {
						System.out.println("/!\\ BUNGEEDNS<WAITING-FOR-DNS-DELETE(" + delete + ")/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
					}else if (done && deleteTime > System.currentTimeMillis()) {
						System.out.println("/!\\ BUNGEEDNS<WAITING-FOR-DELETE(" + (deleteTime - System.currentTimeMillis()) + "/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
					}else if (done) {
						System.out.println("/!\\ BUNGEEDNS<DONE-WAIT-FOR-PLAYERS-UNFILL/" + time + "/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
					}else{
						System.out.println("/!\\ BUNGEEDNS<RUNNING/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
					}
					if (done && delete == 0) {
						delete = -1;
						for (int i = 0; i < 100; i++) {
							DNSDeleteRecord dns = new DNSDeleteRecord(access, "badblock.fr", recordId);
							try {
								JSONObject object = dns.executeBasic();
								System.out.println("Deleting record ID " + recordId);
								if (object != null) {
									System.out.println("Deleted record ID " + recordId);
									break;
								}
								dns.close();
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
						deleteTime = System.currentTimeMillis() + 300_000L;
						System.out.println("/!\\ BUNGEEDNS!<EVENT-BYEDNS!/" + BadBlockBungeeOthers.getInstance().getPlayers() + "/" + BadBlockBungeeOthers.getInstance().getConnections() + "> /!\\");
					}else if (done && delete > 0) delete--;
					if (done && delete == -1 && deleteTime < System.currentTimeMillis()) {
						time--;
						if (time == 60 * 30) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 30 minutes.");
						}else if (time == 60 * 20) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 20 minutes.");
						}else if (time == 60 * 15) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 15 minutes.");
						}else if (time == 60 * 10) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 10 minutes.");
						}else if (time == 60 * 5) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 5 minutes.");
						}else if (time == 60 * 4) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 4 minutes.");
						}else if (time == 60 * 3) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 3 minutes.");
						}else if (time == 60 * 2) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 2 minutes.");
						}else if (time == 60 * 1) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 1 minute.");
						}else if (time == 45) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 45 secondes.");
						}else if (time == 30) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 30 secondes.");
						}else if (time == 15) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 15 secondes.");
						}else if (time == 10) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 10 secondes.");
						}else if (time == 5) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 5 secondes.");
						}else if (time == 4) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 4 secondes.");
						}else if (time == 3) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 3 secondes.");
						}else if (time == 2) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 2 secondes.");
						}else if (time == 1) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eVous allez être déconnecté de cette absorbance dans 1 seconde.");
						}else if (time == 0) {
							BungeeCord.getInstance().broadcast("§f[§cAbsorbance§f] §eDéconnexion de cette absorbance...");
							System.exit(-1);
						}
					}
				}
			};
			new Timer().schedule(timerTask, 1000L, 1000L);
		}
	}

	@Override
	public void onDisable() {
		filters.forEach(filter -> filter.reset());
		if (access != null && recordId != -1) {
			DNSDeleteRecord dns = new DNSDeleteRecord(access, "badblock.fr", recordId);
			try {
				dns.executeBasic();
				dns.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		if (timerTask != null) timerTask.cancel();
		if (timerTask2 != null) timerTask2.cancel();
		finished = true;
		if (redisConnector != null)
			redisConnector.getSyncObject("bungee_" + configuration.getInt("redis.machineId"), bungeeDataType, new Callback<HashMap<String, Bungee>>() {
				@Override
				public void done(HashMap<String, Bungee> result, Throwable error) {
					@SuppressWarnings("deprecation")
					String a = ProxyServer.getInstance().getConfig().getListeners().iterator().next().getHost().getHostString() + ":" + ProxyServer.getInstance().getConfig().getListeners().iterator().next().getHost().getPort();
					if (result.containsKey(a)) {
						Bungee bungee = result.get(a);
						bungee.done = false;
						bungee.bungeeTimestamp = 0;
					}
					redisConnector.set("bungee_" + configuration.getInt("redis.machineId"), result);
				}
			}, false);
	}

	public String getMessage(List<String> list) {
		StringBuilder stringBuilder = new StringBuilder();
		Iterator<String> iterator = list.iterator();
		while (iterator.hasNext()) {
			String message = iterator.next();
			stringBuilder.append(message);
			if (iterator.hasNext())
				stringBuilder.append(System.lineSeparator());
		}
		return stringBuilder.toString();
	}

	private static SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");

	public static String getDate() {
		return dateFormat.format(new Date());
	}

}
