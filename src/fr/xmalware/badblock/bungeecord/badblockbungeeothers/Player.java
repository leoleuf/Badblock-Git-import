package fr.xmalware.badblock.bungeecord.badblockbungeeothers;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import fr.xmalware.badblock.bungeecord.badblockbungeeothers.logs.filters.CustomChannelHandlerContext;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.logs.filters.CustomChannelWrapper;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.logs.filters.CustomInitialHandler;
import fr.xmalware.badblock.bungeecord.badblockbungeeothers.modules.BadPseudoModule;
import lombok.Getter;
import lombok.Setter;
import net.md_5.bungee.BungeeCord;
import net.md_5.bungee.UserConnection;
import net.md_5.bungee.api.connection.ProxiedPlayer;
import net.md_5.bungee.connection.InitialHandler;
import net.md_5.bungee.netty.ChannelWrapper;

@Getter @Setter public class Player {

	private static Map<String, Player> players = new HashMap<>();

	private String					   pseudo;
	private long					   lastMessageTime;
	private String					   lastMessage;
	private Map<String, Long>		   spamMessages;
	private List<UUID>		   		   uuids		= new ArrayList<>();

	@SuppressWarnings("unchecked")
	public Player(ProxiedPlayer player) {
		if (BadPseudoModule.getInstance().check(player)) return;
		this.pseudo = player.getName();
		this.spamMessages = new HashMap<>();
		try {
			if (this.pseudo.length() >= 7) {
				for (int i = 0; i < new Random().nextInt(2) + 1; i++) {
					BungeeCord bungee = BungeeCord.getInstance();
					Field connectionLock = BungeeCord.class.getDeclaredField("connectionLock");
					connectionLock.setAccessible(true);
					ReentrantReadWriteLock connectionLockObject = (ReentrantReadWriteLock) connectionLock.get(bungee);
					connectionLockObject.writeLock().lock();
					Field connections = BungeeCord.class.getDeclaredField("connections");
					connections.setAccessible(true);
					Map<String, UserConnection> connectionsObject = (Map<String, UserConnection>) connections.get(bungee);
					ChannelWrapper channelWrapper = new CustomChannelWrapper(new CustomChannelHandlerContext());
					InitialHandler initialHandler = new CustomInitialHandler(bungee, bungee.getConfig().getListeners().iterator().next());
					initialHandler.connected(channelWrapper);
					Field uniqueId = InitialHandler.class.getDeclaredField("uniqueId");
					uniqueId.setAccessible(true);
					UUID uuid = UUID.randomUUID();
					uuids.add(uuid);
					uniqueId.set(initialHandler, uuid);
					UserConnection userConnection = new UserConnection(bungee, channelWrapper, uuid.toString(), initialHandler);
					connectionsObject.put(uuid.toString(), userConnection);
					connectionLockObject.writeLock().unlock();
				}
			}
		}catch(Exception error) {
			error.printStackTrace();
		}
		players.put(pseudo, this);
	}

	public void remove() {
		if (!this.uuids.isEmpty()) {
			try {
				for (UUID uuid : uuids) {
					BungeeCord bungee = BungeeCord.getInstance();
					Field connectionLock = BungeeCord.class.getDeclaredField("connectionLock");
					connectionLock.setAccessible(true);
					ReentrantReadWriteLock connectionLockObject = (ReentrantReadWriteLock) connectionLock.get(bungee);
					connectionLockObject.writeLock().lock();
					Field connections = BungeeCord.class.getDeclaredField("connections");
					connections.setAccessible(true);
					@SuppressWarnings("unchecked")
					Map<String, UserConnection> connectionsObject = (Map<String, UserConnection>) connections.get(bungee);
					connectionsObject.remove(uuid.toString());
					connectionLockObject.writeLock().unlock();
				}
			}catch(Exception error) {
				error.printStackTrace();
			}
		}
		players.remove(this);
	}

	public static Player get(ProxiedPlayer proxiedPlayer) {
		if (!players.containsKey(proxiedPlayer.getName())) return new Player(proxiedPlayer);
		return players.get(proxiedPlayer.getName());
	}

}
