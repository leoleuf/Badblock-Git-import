package fr.xmalware.badblock.hub.utils;

import java.util.ArrayList;
import java.util.Random;

import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;

/*
 * Le Cuboid est utilisé pour sa simplicité à délimiter des zones
 */

/**
 * 
 * @author xMalware
 *
 */
public class Cuboid {
	public Cuboid(Location point1, Location point2) {
		xMin = Math.min(point1.getBlockX(), point2.getBlockX());
		xMax = Math.max(point1.getBlockX(), point2.getBlockX());
		yMin = Math.min(point1.getBlockY(), point2.getBlockY());
		yMax = Math.max(point1.getBlockY(), point2.getBlockY());
		zMin = Math.min(point1.getBlockZ(), point2.getBlockZ());
		zMax = Math.max(point1.getBlockZ(), point2.getBlockZ());
		world = point1.getWorld();
		// Blocs centrés
		xMinCentered = xMin + 0.5;
		xMaxCentered = xMax + 0.5;
		yMinCentered = yMin + 0.5;
		yMaxCentered = yMax + 0.5;
		zMinCentered = zMin + 0.5;
		zMaxCentered = zMax + 0.5;
	}
	
	private int	xMin, xMax, yMin, yMax, zMin, zMax;
	private double	xMinCentered, xMaxCentered, yMinCentered, yMaxCentered, zMinCentered, zMaxCentered;
	private World	world;
	
	/**
	 * La location est dans le bloc
	 * @param loc
	 * @return
	 */
	public boolean isIn(Location loc) {
		if (loc.getWorld() != this.world) return false;
		if (loc.getBlockX() < xMin) return false;
		if (loc.getBlockX() > xMax) return false;
		if (loc.getBlockY() < yMin) return false;
		if (loc.getBlockY() > yMax) return false;
		if (loc.getBlockZ() < zMin) return false;
		if (loc.getBlockZ() > zMax) return false;
		return true;
	}
	
	/**
	 * La location est dans le bloc avec de la marge
	 * @param loc
	 * @param marge en blocs
	 * @return
	 */
	public boolean isInWithMarge(Location loc, double marge) {
		if (loc.getWorld() != this.world) return false;
		if (loc.getX() < xMinCentered - marge) return false;
		if (loc.getX() > xMaxCentered + marge) return false;
		if (loc.getY() < yMinCentered - marge) return false;
		if (loc.getY() > yMaxCentered + marge) return false;
		if (loc.getZ() < zMinCentered - marge) return false;
		if (loc.getZ() > zMaxCentered + marge) return false;
		return true;
	}
	
	public int getXWidth() {
		return (xMax - xMin) + 1;
	}
	public int getZWidth() {
		return (zMax - zMin) + 1;
	}
	public int getHeight() {
		return (yMax - yMin) + 1;
	}
	public int getTotalBlockSize() {
		return getHeight() * getXWidth() * getZWidth();
	}
	
	public Location getPoint1() {
		return new Location(world, xMin, yMin, zMin);
	}
	
	public Location getPoint2() {
		return new Location(world, xMax, yMax, zMax);
	}
	
	// Tous les blocks d'un cuboid
	public ArrayList<Block> blockList() {
		ArrayList<Block> bL = new ArrayList<Block>();
		for (int x = xMin; x <= xMax; x++) {
			for (int y = yMin; y <= yMax; y++) {
				for (int z = zMin; z <= zMax; z++) {
					Block b = world.getBlockAt(x, y, z);
					bL.add(b);
				}
			}
		}
		return bL;
	}
	
	public double getDistance() {
		return getPoint1().distance(getPoint2());
	}
	
	public double getDistanceSquared() {
		return getPoint1().distanceSquared(getPoint2());
	}
	
	/**
	 * Un bloc au hasard dans le cuboid
	 * @return
	 */
	public Location getRandomLocation() {
		Random rand = new Random();
		int x = rand.nextInt(Math.abs(xMax - xMin) + 1) + xMin;
		int y = rand.nextInt(Math.abs(yMax - yMin) + 1) + yMin;
		int z = rand.nextInt(Math.abs(zMax - zMin) + 1) + zMin;
		return new Location(world, x, y, z);
	}
	
	/**
	 * Le milieu du cuboid
	 * @return
	 */
	public Location getCenter() {
		return new Location(world, (xMax-xMin)/2+xMin, (yMax-yMin)/2+yMin, (zMax-zMin)/2+zMin);
	}
}
