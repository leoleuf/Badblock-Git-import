package fr.xmalware.badblock.hub.listeners.vipzone;

import java.util.ArrayList;
import java.util.List;

import org.bukkit.Effect;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerTeleportEvent;

import fr.badblock.gameapi.players.BadblockPlayer;
import fr.badblock.gameapi.utils.ConfigUtils;
import fr.badblock.gameapi.utils.threading.TaskManager;
import fr.xmalware.badblock.hub.BadBlockHub;
import fr.xmalware.badblock.hub.listeners._HubListener;
import fr.xmalware.badblock.hub.objects.HubPlayer;

public class RaceListener extends _HubListener {

	public List<RaceCell>  	  			raceEnterFences = new ArrayList<>();
	public static List<BadblockPlayer>  racePlayers		= new ArrayList<>();
	public static List<BadblockPlayer>  winnerOrder		= new ArrayList<>();;
	public static RaceState	  			raceState	    = RaceState.WAITING;
	private int seconds = -1;
	private int minPlayers = 2;
	private int launchCountdownConfig = 120;
	private List<Integer> notifySeconds = new ArrayList<>();

	public RaceListener(BadBlockHub hub) {
		FileConfiguration configuration = hub.getConfig();
		ConfigurationSection configurationSection = configuration.getConfigurationSection("race.cells");
		raceEnterFences.clear();
		winnerOrder.clear();
		raceState = RaceState.WAITING;
		racePlayers.clear();
		minPlayers = ConfigUtils.get(hub, "race.minPlayers", 2);
		notifySeconds = ConfigUtils.getIntList(hub, "race.notifySeconds");
		launchCountdownConfig = ConfigUtils.get(hub, "race.launchCountdownConfig", 120);
		configurationSection.getKeys(false).forEach(key -> {
			Location blockLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".blockLocation");
			Location cellLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".cellLocation");
			Location aheadLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".aheadLocation");
			Location breakableBlockLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".breakableBlockLocation");
			RaceCell raceCell = new RaceCell(blockLocation, cellLocation, aheadLocation, breakableBlockLocation);
			raceEnterFences.add(raceCell);
		});
		TaskManager.scheduleSyncRepeatingTask("raceTask", new Runnable() {
			@SuppressWarnings("deprecation")
			@Override
			public void run() {
				if (raceState.equals(RaceState.WAITING)) {
					if (racePlayers.size() >= minPlayers) {
						seconds = launchCountdownConfig;
						raceState = RaceState.LAUNCHING;
						racePlayers.forEach(player -> player.sendTranslatedMessage("hub.race.launched_countdown_there_is_enough_players", racePlayers.size()));
					}
				}else if (raceState.equals(RaceState.LAUNCHING)) {
					if (racePlayers.size() < minPlayers) {
						racePlayers.forEach(player -> player.sendTranslatedMessage("hub.race.stopped_countdown_there_isnt_enough_players", racePlayers.size()));
					}else{
						if (seconds <= 0) {
							raceState = RaceState.RUNNING;
							racePlayers.forEach(player -> player.sendTranslatedMessage("hub.race.go", racePlayers.size()));
							raceEnterFences.forEach(raceCell -> {
								Location breakableBlockLocation = raceCell.breakableBlockLocation;
								racePlayers.forEach(racePlayer -> racePlayer.playEffect(breakableBlockLocation, Effect.EXPLOSION_HUGE, 1));
								breakableBlockLocation.getBlock().setType(Material.AIR);
							});
						}else{
							if (notifySeconds.contains(seconds)) {
								racePlayers.forEach(player -> player.sendTranslatedMessage("hub.race.time_to_be_launched_" + (seconds >= 86400 ? "days" : seconds >= 3600 ? "hours" : seconds >= 60 ? "minutes" : "seconds"), seconds / (seconds >= 86400 ? 86400 : seconds >= 3600 ? 3600 : seconds >= 60 ? 60 : 1)));
							}
							seconds--;
						}
					}
				}
			}
		}, 20, 20);
	}

	@EventHandler (priority = EventPriority.HIGHEST)
	public void onPlayerInteract(PlayerInteractEvent event) {
		BadblockPlayer player = (BadblockPlayer) event.getPlayer();
		Action action = event.getAction();
		if (action.equals(Action.RIGHT_CLICK_BLOCK)) {
			Block block = event.getClickedBlock();
			Location location = block.getLocation();
			for (RaceCell raceCell : raceEnterFences)
				if (equals(location, raceCell.getBlockLocation())) {
					event.setCancelled(true);
					if (racePlayers.contains(player)) {
						// sorti
						player.sendTranslatedMessage("hub.race.you_left");
						if (raceState.equals(RaceState.WAITING)) racePlayers.forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.has_left", player.getTabGroupPrefix().getAsLine(racePlayer) + " " + player.getName()));
						else if (raceState.equals(RaceState.RUNNING) || raceState.equals(RaceState.LAUNCHING)) racePlayers.forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.has_abandoned", player.getTabGroupPrefix().getAsLine(racePlayer) + " " + player.getName()));
						racePlayers.remove(player);
						player.teleport(raceCell.getAheadCellLocaton());
					}else{
						if (!raceState.equals(RaceState.WAITING)) {
							if (raceState.equals(RaceState.LAUNCHING))
								racePlayers.forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.cannot_join_just_launch"));
							else if (raceState.equals(RaceState.RUNNING))
								racePlayers.forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.cannot_join_running"));
							else
								racePlayers.forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.cannot_join_finished"));
							return;
						}
						if (player.isDisguised()) player.undisguise();
						if (player.isInsideVehicle()) player.getVehicle().remove();
						HubPlayer hubPlayer = HubPlayer.get(player);
						hubPlayer.getParticles().forEach(particle -> particle.cancel());
						hubPlayer.getParticles().clear();
						racePlayers.add(player);
						player.sendTranslatedMessage("hub.race.you_join");
						if (raceState.equals(RaceState.WAITING)) racePlayers.forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.has_join", player.getTabGroupPrefix().getAsLine(racePlayer) + " " + player.getName()));
						player.teleport(raceCell.getCellLocation());
					}
					break;	
				}
			return;
		}
	}

	@EventHandler (priority = EventPriority.LOWEST, ignoreCancelled = true)
	public void onPlayerTeleport(PlayerTeleportEvent event) {
		BadblockPlayer player = (BadblockPlayer) event.getPlayer();
		if (racePlayers.contains(player)) event.setCancelled(true);
	}

	@EventHandler (priority = EventPriority.LOWEST, ignoreCancelled = true)
	public void onPlayerMove(PlayerMoveEvent event) {
		BadblockPlayer player = (BadblockPlayer) event.getPlayer();
		if (racePlayers.contains(player)) {
			if (raceState.equals(RaceState.WAITING) || raceState.equals(RaceState.LAUNCHING)) {
				if (!equals(event.getFrom(), event.getTo()))
					event.setCancelled(true);
			}
		}
	}

	public boolean equals(Location location, Location location2) {
		return ConfigUtils.convertLocationBlockToString(location).equals(ConfigUtils.convertLocationBlockToString(location2));
	}

	enum RaceState {
		WAITING,
		LAUNCHING,
		RUNNING,
		FINISHED;
	}

}
