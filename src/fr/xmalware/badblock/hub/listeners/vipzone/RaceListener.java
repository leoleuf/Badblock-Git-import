package fr.xmalware.badblock.hub.listeners.vipzone;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.bukkit.Effect;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerTeleportEvent;

import fr.badblock.gameapi.players.BadblockPlayer;
import fr.badblock.gameapi.utils.ConfigUtils;
import fr.badblock.gameapi.utils.selections.CuboidSelection;
import fr.badblock.gameapi.utils.threading.TaskManager;
import fr.xmalware.badblock.hub.BadBlockHub;
import fr.xmalware.badblock.hub.listeners._HubListener;
import fr.xmalware.badblock.hub.objects.HubPlayer;

public class RaceListener extends _HubListener {

	public List<RaceCell>  	  			raceEnterFences = new ArrayList<>();
	public static Map<BadblockPlayer, RaceCell>  racePlayers = new HashMap<>();
	public static Map<BadblockPlayer, Double>  winnerOrder		= new HashMap<>();;
	public static RaceState	  			raceState	    = RaceState.WAITING;
	private int seconds = -1;
	private int minPlayers = 2;
	private int waitingCountdownConfig = 30;
	private int launchingCountdownConfig = 10;
	private int finishedCountdownConfig = 10;
	private long start;
	private List<Integer> notifySeconds = new ArrayList<>();
	private Location frontLocation;
	private Location lineLocation1;
	private Location lineLocation2;
	private CuboidSelection lineCuboid;
	
	public RaceListener(BadBlockHub hub) {
		FileConfiguration configuration = hub.getConfig();
		ConfigurationSection configurationSection = configuration.getConfigurationSection("race.cells");
		raceEnterFences.clear();
		winnerOrder.clear();
		raceState = RaceState.WAITING;
		racePlayers.clear();
		minPlayers = ConfigUtils.get(hub, "race.minPlayers", 2);
		notifySeconds = ConfigUtils.getIntList(hub, "race.notifySeconds");
		frontLocation = ConfigUtils.getLocation(hub, "race.front");
		lineLocation1 = ConfigUtils.getLocation(hub, "race.line.loc1");
		lineLocation2 = ConfigUtils.getLocation(hub, "race.line.loc2");
		lineCuboid = new CuboidSelection(lineLocation1, lineLocation2);
		waitingCountdownConfig = ConfigUtils.get(hub, "race.waitingCountdownConfig", 30);
		launchingCountdownConfig = ConfigUtils.get(hub, "race.launchCountdownConfig", 10);
		finishedCountdownConfig = ConfigUtils.get(hub, "race.finishedCountdownConfig", 10);
		configurationSection.getKeys(false).forEach(key -> {
			Location blockLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".blockLocation");
			Location cellLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".cellLocation");
			Location aheadLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".aheadLocation");
			Location breakableBlockLocation = ConfigUtils.getLocation(hub, "race.cells." + key + ".breakableBlockLocation");
			RaceCell raceCell = new RaceCell(blockLocation, cellLocation, aheadLocation, breakableBlockLocation);
			raceEnterFences.add(raceCell);
		});
		TaskManager.scheduleSyncRepeatingTask("raceTask", new Runnable() {
			@SuppressWarnings("deprecation")
			@Override
			public void run() {
				Iterator<Entry<BadblockPlayer, RaceCell>> iterator = racePlayers.entrySet().iterator();
				while (iterator.hasNext()) {
					Entry<BadblockPlayer, RaceCell> entry = iterator.next();
					if (entry.getKey() == null || !entry.getKey().isOnline() || !entry.getKey().isValid())
						iterator.remove();
				}
				if (raceState.equals(RaceState.WAITING)) {
					raceEnterFences.forEach(raceCell -> {
						Location breakableBlockLocation = raceCell.breakableBlockLocation;
						breakableBlockLocation.getBlock().setType(Material.getMaterial(107));
					});
					if (racePlayers.size() >= minPlayers && seconds == -1) {
						seconds = waitingCountdownConfig;
						raceState = RaceState.LAUNCHING;
						racePlayers.keySet().forEach(player -> player.sendTranslatedMessage("hub.race.launched_countdown_there_is_enough_players", racePlayers.size()));
					}else{
						if (racePlayers.size() < minPlayers) {
							raceEnterFences.forEach(raceCell -> {
								Location breakableBlockLocation = raceCell.breakableBlockLocation;
								breakableBlockLocation.getBlock().setType(Material.getMaterial(107));
							});
							racePlayers.keySet().forEach(player -> {
								player.sendTranslatedMessage("hub.race.stopped_countdown_there_isnt_enough_players", racePlayers.size());
								player.teleport(frontLocation);
							});
							seconds = -1;
						}
						if (seconds <= 0) {
							seconds = launchingCountdownConfig;
							raceState = RaceState.LAUNCHING;
							racePlayers.keySet().forEach(player -> player.sendTranslatedMessage("hub.race.preparation", racePlayers.size()));
						}else{
							if (notifySeconds.contains(seconds)) {
								racePlayers.keySet().forEach(player -> player.sendTranslatedMessage("hub.race.waiting_time_to_be_launched_" + (seconds >= 86400 ? "days" : seconds >= 3600 ? "hours" : seconds >= 60 ? "minutes" : "seconds"), seconds / (seconds >= 86400 ? 86400 : seconds >= 3600 ? 3600 : seconds >= 60 ? 60 : 1)));
							}
							seconds--;
						}
					}
				}else if (raceState.equals(RaceState.LAUNCHING)) {
					if (racePlayers.size() < minPlayers) {
						seconds = waitingCountdownConfig;
						raceState = RaceState.WAITING;
						raceEnterFences.forEach(raceCell -> {
							Location breakableBlockLocation = raceCell.breakableBlockLocation;
							breakableBlockLocation.getBlock().setType(Material.getMaterial(107));
						});
						racePlayers.keySet().forEach(player -> {
							player.sendTranslatedMessage("hub.race.stopped_countdown_there_isnt_enough_players", racePlayers.size());
							player.teleport(frontLocation);
						});
					}else{
						if (seconds <= 0) {
							raceState = RaceState.RUNNING;
							raceEnterFences.forEach(raceCell -> {
								Location breakableBlockLocation = raceCell.breakableBlockLocation;
								racePlayers.keySet().forEach(racePlayer -> racePlayer.playEffect(breakableBlockLocation, Effect.EXPLOSION_HUGE, 1));
								breakableBlockLocation.getBlock().setType(Material.AIR);
							});
							start = System.currentTimeMillis();
						}else{
							if (notifySeconds.contains(seconds)) {
								racePlayers.keySet().forEach(player -> player.sendTranslatedMessage("hub.race.launching_time_to_be_able_to_run_" + (seconds >= 86400 ? "days" : seconds >= 3600 ? "hours" : seconds >= 60 ? "minutes" : "seconds"), seconds / (seconds >= 86400 ? 86400 : seconds >= 3600 ? 3600 : seconds >= 60 ? 60 : 1)));
							}
							seconds--;
						}
					}
				}else if (raceState.equals(RaceState.RUNNING)) {
					if (racePlayers.size() < minPlayers) {
						win(RaceFinishType.NO_ENOUGH_PLAYERS);
					}else{
						if (seconds <= 0) {
							raceState = RaceState.RUNNING;
							raceEnterFences.forEach(raceCell -> {
								Location breakableBlockLocation = raceCell.breakableBlockLocation;
								racePlayers.keySet().forEach(racePlayer -> racePlayer.playEffect(breakableBlockLocation, Effect.EXPLOSION_HUGE, 1));
								breakableBlockLocation.getBlock().setType(Material.AIR);
							});
						}else{
							if (notifySeconds.contains(seconds)) {
								racePlayers.keySet().forEach(player -> player.sendTranslatedMessage("hub.race.launching_time_to_be_able_to_run_" + (seconds >= 86400 ? "days" : seconds >= 3600 ? "hours" : seconds >= 60 ? "minutes" : "seconds"), seconds / (seconds >= 86400 ? 86400 : seconds >= 3600 ? 3600 : seconds >= 60 ? 60 : 1)));
							}
							seconds--;
						}
					}
				}
			}
		}, 20, 20);
	}

	@SuppressWarnings("deprecation")
	private void win(Map<BadblockPlayer, Double> winnerOrder, RaceFinishType finishType) {
		seconds = finishedCountdownConfig;
		raceState = RaceState.FINISHED;
		raceEnterFences.forEach(raceCell -> {
			Location breakableBlockLocation = raceCell.breakableBlockLocation;
			breakableBlockLocation.getBlock().setType(Material.getMaterial(107));
		});
		if (winnerOrder.isEmpty()) {
			racePlayers.keySet().forEach(player -> player.sendTranslatedMessage("hub.race.win_nowinner"));
			return;
		}
		String winner0Name = null, winner1Name = null, winner2Name = null, winner3Name = null, winner4Name = null;
		double winner0Time = 0, winner1Time = 0, winner2Time = 0, winner3Time = 0, winner4Time = 0;
		Iterator<Entry<BadblockPlayer, Double>> iterator = winnerOrder.entrySet().iterator();
		int i = 0;
		while (iterator.hasNext()) {
			Entry<BadblockPlayer, Double> entry = iterator.next();
			if (i == 0) {
				winner0Name = entry.getKey().getGroupPrefix() + entry.getKey().getName();
				winner0Time = entry.getValue();
			}else if (i == 1) {
				winner1Name = entry.getKey().getGroupPrefix() + entry.getKey().getName();
				winner1Time = entry.getValue();
			}else if (i == 2) {
				winner2Name = entry.getKey().getGroupPrefix() + entry.getKey().getName();
				winner2Time = entry.getValue();
			}else if (i == 3) {
				winner3Name = entry.getKey().getGroupPrefix() + entry.getKey().getName();
				winner3Time = entry.getValue();
			}else if (i == 4) {
				winner4Name = entry.getKey().getGroupPrefix() + entry.getKey().getName();
				winner4Time = entry.getValue();
			}
			i++;
		}
		String fWinner0Name = winner0Name, fWinner1Name = winner1Name, fWinner2Name = winner2Name, fWinner3Name = winner3Name, fWinner4Name = winner4Name;
		double fWinner0Time = winner0Time, fWinner1Time = winner1Time, fWinner2Time = winner2Time, fWinner3Time = winner3Time, fWinner4Time = winner4Time;
		racePlayers.keySet().forEach(player -> player.sendTranslatedMessage("hub.race.win", (finishType.equals(RaceFinishType.ALL_PLAYERS_FINISHED) ?
				player.getTranslatedMessage("hub.race.wintype_allplayersfinished") : finishType.equals(RaceFinishType.NO_ENOUGH_PLAYERS) ? player.getTranslatedMessage("hub.race.wintype_noenoughplayers")
						: player.getTranslatedMessage("hub.race.wintype_unknown")), (fWinner0Name != null ? fWinner0Name : player.getTranslatedMessage("hub.race.nullwinner")),
				(fWinner0Name != null ? fWinner0Time : player.getTranslatedMessage("hub.race.nullwinnertime")),(fWinner1Name != null ? fWinner1Name : player.getTranslatedMessage("hub.race.nullwinner")),
				(fWinner1Name != null ? fWinner1Time : player.getTranslatedMessage("hub.race.nullwinnertime")),(fWinner2Name != null ? fWinner2Name : player.getTranslatedMessage("hub.race.nullwinner")),
				(fWinner2Name != null ? fWinner2Time : player.getTranslatedMessage("hub.race.nullwinnertime")),(fWinner3Name != null ? fWinner3Name : player.getTranslatedMessage("hub.race.nullwinner")),
				(fWinner3Name != null ? fWinner3Time : player.getTranslatedMessage("hub.race.nullwinnertime")),(fWinner4Name != null ? fWinner4Name : player.getTranslatedMessage("hub.race.nullwinner")),
				(fWinner4Name != null ? fWinner4Time : player.getTranslatedMessage("hub.race.nullwinnertime"))));
		List<BadblockPlayer> players = new ArrayList<>(racePlayers.keySet());
		players.forEach(player -> player.teleport(frontLocation));
		racePlayers.clear();
	}
	
	private void win(RaceFinishType finishType) {
		win(winnerOrder, finishType);
	}
	
	@EventHandler (priority = EventPriority.HIGHEST)
	public void onPlayerInteract(PlayerInteractEvent event) {
		BadblockPlayer player = (BadblockPlayer) event.getPlayer();
		Action action = event.getAction();
		if (action.equals(Action.RIGHT_CLICK_BLOCK)) {
			Block block = event.getClickedBlock();
			Location location = block.getLocation();
			for (RaceCell raceCell : raceEnterFences)
				if (equals(location, raceCell.getBlockLocation())) {
					event.setCancelled(true);
					if (racePlayers.containsKey(player)) {
						// sorti
						player.sendTranslatedMessage("hub.race.you_left");
						if (raceState.equals(RaceState.WAITING)) racePlayers.keySet().forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.has_left", player.getTabGroupPrefix().getAsLine(racePlayer) + player.getName()));
						else if (raceState.equals(RaceState.RUNNING) || raceState.equals(RaceState.LAUNCHING)) racePlayers.keySet().forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.has_abandoned", player.getTabGroupPrefix().getAsLine(racePlayer) + player.getName()));
						racePlayers.remove(player);
						player.teleport(raceCell.getAheadCellLocaton());
					}else{
						if (racePlayers.containsValue(raceCell)) {
							player.sendTranslatedMessage("hub.race.already_used");
							return;
						}
						if (!raceState.equals(RaceState.WAITING)) {
							if (raceState.equals(RaceState.LAUNCHING))
								player.sendTranslatedMessage("hub.race.cannot_join_just_launch");
							else if (raceState.equals(RaceState.RUNNING))
								player.sendTranslatedMessage("hub.race.cannot_join_running");
							else
								player.sendTranslatedMessage("hub.race.cannot_join_finished");
							return;
						}
						if (player.isDisguised()) player.undisguise();
						if (player.isInsideVehicle()) player.getVehicle().remove();
						HubPlayer hubPlayer = HubPlayer.get(player);
						hubPlayer.getParticles().forEach(particle -> particle.cancel());
						hubPlayer.getParticles().clear();
						player.teleport(raceCell.getCellLocation());
						racePlayers.put(player, raceCell);
						player.sendTranslatedMessage("hub.race.you_join");
						if (raceState.equals(RaceState.WAITING)) racePlayers.keySet().forEach(racePlayer -> racePlayer.sendTranslatedMessage("hub.race.has_join", player.getTabGroupPrefix().getAsLine(racePlayer) + player.getName()));
					}
					break;	
				}
			return;
		}
	}

	@EventHandler (priority = EventPriority.LOWEST, ignoreCancelled = true)
	public void onPlayerTeleport(PlayerTeleportEvent event) {
		BadblockPlayer player = (BadblockPlayer) event.getPlayer();
		if (racePlayers.containsKey(player)) event.setCancelled(true);
	}

	@EventHandler (priority = EventPriority.LOWEST, ignoreCancelled = true)
	public void onPlayerMove(PlayerMoveEvent event) {
		BadblockPlayer player = (BadblockPlayer) event.getPlayer();
		if (racePlayers.containsKey(player)) {
			if (raceState.equals(RaceState.WAITING) || raceState.equals(RaceState.LAUNCHING)) {
				if (!equals(event.getFrom(), event.getTo()))
					event.setTo(event.getFrom());
			}else if (raceState.equals(RaceState.RUNNING)) {
				if (lineCuboid.isInSelection(event.getTo()) && !winnerOrder.containsKey(player)) {
					long time = System.currentTimeMillis() - start;
					double formatTime = Double.parseDouble(String.format("%.2f", time));
					player.sendTranslatedMessage("hub.race.you_finish", formatTime);
				}
			}
		}
	}

	public boolean equals(Location location, Location location2) {
		return ConfigUtils.convertLocationBlockToString(location).equals(ConfigUtils.convertLocationBlockToString(location2));
	}

	public enum RaceState {
		WAITING,
		LAUNCHING,
		RUNNING,
		FINISHED;
	}
	
	public enum RaceFinishType {
		NO_ENOUGH_PLAYERS,
		ALL_PLAYERS_FINISHED;
	}

}
