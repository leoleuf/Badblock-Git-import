package fr.xmalware.badblock.hub.inventories.cosmetics.chests;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;

import org.bukkit.Bukkit;
import org.bukkit.Effect;
import org.bukkit.Location;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;

import fr.badblock.gameapi.players.BadblockPlayer;
import fr.xmalware.badblock.hub.BadBlockHub;
import fr.xmalware.badblock.hub.inventories.abstracts.actions.ItemAction;
import fr.xmalware.badblock.hub.inventories.abstracts.inventories.CustomPlayerInventory;
import fr.xmalware.badblock.hub.inventories.abstracts.items.CustomItem;
import fr.xmalware.badblock.hub.inventories.settings.items.BlueStainedGlassPaneItem;
import fr.xmalware.badblock.hub.objects.HubPlayer;
import fr.xmalware.badblock.hub.objects.HubStoredPlayer;
import net.minecraft.server.v1_8_R3.BlockPosition;
import net.minecraft.server.v1_8_R3.PacketPlayOutBlockAction;

public class PlayerChestsSelectorInventory extends CustomPlayerInventory {

	public PlayerChestsSelectorInventory() {
		super("hub.items.chestsinventory", 3);
	}

	@SuppressWarnings("deprecation")
	@Override
	public void init(BadblockPlayer player) {
		this.getItems().clear();
		BlueStainedGlassPaneItem blueStainedGlassPaneItem = new BlueStainedGlassPaneItem();
		for (int id = 0; id < this.getLines() * 9; id++)
			if ((id == 0 || id < 9 || id % 9 == 0 || id == 17 || id == 26 || id == 35 || id == 44 || id == 53
			|| id > (9 * (this.getLines() - 1)) - 1))
				this.setItem(blueStainedGlassPaneItem, id);
		this.setAsLastItem(new PlayerQuitChestsItem());
		HubStoredPlayer hubStoredPlayer = HubStoredPlayer.get(player);
		if (hubStoredPlayer == null) return;
		Map<Integer, CustomChestType> chestsTypes = new HashMap<>();
		ChestLoader chestLoader = ChestLoader.getInstance();
		chestLoader.getChests().forEach(chest -> chestsTypes.put(chest.getId(), chest));
		hubStoredPlayer.getChests().stream().filter(chests -> !chests.isOpened()).forEach(chests -> {
			if (!chestsTypes.containsKey(chests.getTypeId())) {
				System.out.println("[HUB] Unknown chest type (id: " + chests.getTypeId() + " / " + player.getName() + ")");
				return;
			}
			CustomChestType chestType = chestsTypes.get(chests.getTypeId());
			this.addItem(new CustomItem("hub.chests." + chests.getTypeId() + ".name", chestType.getItemStack().getType(), chestType.getItemStack().getData().getData(), "hub.chests." + chests.getTypeId() + ".lore") {
				@Override
				public void onClick(BadblockPlayer player, ItemAction action, Block clickedBlock) {
					HubPlayer hubPlayer = HubPlayer.get(player);
					if (hubPlayer.getChestOpener() == null) {
						System.out.println("[HUB] Null chestOpener (id: " + chests.getTypeId() + " / " + player.getName() + ")");
						return;
					}
					ChestOpener chestOpener = hubPlayer.getChestOpener();
					// On close son inventaire
					player.closeInventory();
					// On dit à son chest qu'il a déjà été ouvert
					chests.setOpened(true);
					player.saveGameData();
					player.saveData();
					// On le freeze temporairement
					hubPlayer.setChestFreeze(true);
					// On créé un thread spécial pour le chest
					List<String> items = new ArrayList<>();
					new Thread() {
						@Override
						public void run() {
							if (!player.isOnline()) return;
							for (Entry<Location, Location> entry : chestOpener.getChestLocations().entrySet()) {
								// Téléportation au coffre qui va s'ouvrir
								Bukkit.getScheduler().runTask(BadBlockHub.getInstance(), new Runnable() {
									@Override
									public void run() {
										if (!player.isOnline()) return;
										hubPlayer.setChestFreeze(false);
										player.teleport(entry.getValue());
										hubPlayer.setChestFreeze(true);
									}
								});
								// Attente
								try {
									Thread.sleep(1000L);
								} catch (InterruptedException e) {
									e.printStackTrace();
								}
								// Animation d'ouverture du coffre
								Bukkit.getScheduler().runTask(BadBlockHub.getInstance(), new Runnable() {
									@Override
									public void run() {
										if (!player.isOnline()) return;
										player.playEffect(entry.getKey(), Effect.EXPLOSION_HUGE, 1);
										player.playSound(Sound.EXPLODE);
										BlockPosition position = new BlockPosition(entry.getKey().getBlockX(), entry.getKey().getBlockY(), entry.getKey().getBlockZ());
										PacketPlayOutBlockAction blockActionPacket = new PacketPlayOutBlockAction(position, net.minecraft.server.v1_8_R3.Block.getById(entry.getKey().getBlock().getTypeId()), (byte) 1, (byte) 1);
										((CraftPlayer) player).getHandle().playerConnection.sendPacket(blockActionPacket);
										// on va récupérer le winrate total sur l'opener
										int totalWinRate = 0;
										Map<Integer, String> maps = new HashMap<>();
										for (Entry<String, Long> entry : chestType.getWinRates().entrySet()) {
											totalWinRate += entry.getValue();
											maps.put(totalWinRate, entry.getKey());
										}
										boolean done = false;
										while (!done) {
											List<Entry<Integer, String>> entries = maps.entrySet().stream().sorted((e1, e2) -> { return Integer.compare(e2.getKey(), e1.getKey()); }).collect(Collectors.toList());;
											int randomRate = new SecureRandom().nextInt(totalWinRate) + 1;
											Entry<Integer, String> maxEntry = null;
											for (Entry<Integer, String> entry : entries) {
												if (entry.getKey() > randomRate) {
													maxEntry = entry;
													continue;
												}
												break;
											}
											if (!items.contains(maxEntry.getValue())) {
												items.add(maxEntry.getValue());
												if (!hubStoredPlayer.getProperties().contains(maxEntry.getValue())) {
													player.playSound(Sound.LEVEL_UP);
													hubStoredPlayer.getProperties().add(maxEntry.getValue());
													player.saveGameData();
													player.saveData();
												}
												player.sendMessage("Win debug: " + player.getTranslatedMessage("hub.items." + maxEntry.getValue().split("_")[0] + "." + maxEntry.getValue().split("_")[1] + ".displayname") + " / " + maxEntry.getValue());
												done = true;
											}
										}
									}
								});
								try {
									Thread.sleep(1000L);
								} catch (InterruptedException e) {
									e.printStackTrace();
								}
							}
							hubPlayer.setChestFreeze(false);
							// on referme les chests
							for (Entry<Location, Location> entry : chestOpener.getChestLocations().entrySet()) {
								BlockPosition position = new BlockPosition(entry.getKey().getBlockX(), entry.getKey().getBlockY(), entry.getKey().getBlockZ());
								PacketPlayOutBlockAction blockActionPacket = new PacketPlayOutBlockAction(position, net.minecraft.server.v1_8_R3.Block.getById(entry.getKey().getBlock().getTypeId()), (byte) 1, (byte) 0);
								((CraftPlayer) player).getHandle().playerConnection.sendPacket(blockActionPacket);
							}
						}
					}.start();
				}

				@Override
				public List<ItemAction> getActions() {
					return Arrays.asList(ItemAction.INVENTORY_DROP, ItemAction.INVENTORY_LEFT_CLICK,
							ItemAction.INVENTORY_RIGHT_CLICK, ItemAction.INVENTORY_WHEEL_CLICK);
				}

			});
		});
	}

	static <K,V extends Comparable<? super V>> List<Entry<K, V>> entriesSortedByValues(Map<K,V> map) {

		List<Entry<K,V>> sortedEntries = new ArrayList<Entry<K,V>>(map.entrySet());

		Collections.sort(sortedEntries, 
				new Comparator<Entry<K,V>>() {
			@Override
			public int compare(Entry<K,V> e1, Entry<K,V> e2) {
				return e2.getValue().compareTo(e1.getValue());
			}
		});

		return sortedEntries;
	}

}