package fr.xmalware.badblock.hub.tasks;

import java.lang.reflect.Type;
import java.sql.ResultSet;
import java.util.Map;
import java.util.Map.Entry;

import org.bukkit.Bukkit;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import fr.badblock.gameapi.GameAPI;
import fr.badblock.gameapi.databases.SQLRequestType;
import fr.badblock.gameapi.utils.general.Callback;
import fr.xmalware.badblock.hub.BadBlockHub;
import fr.xmalware.badblock.hub.npc.NPCData;

public class RequestNPCTask extends CustomTask {

	private static final Type type = new TypeToken<Map<Integer, NPCData>>() {}.getType();

	public RequestNPCTask() {
		super(600, 600);
	}

	@Override
	public void done() {
		GameAPI.getAPI().getSqlDatabase().call("SELECT value FROM keyValues WHERE `key` = 'npc'", SQLRequestType.QUERY, new Callback<ResultSet>() {

			@Override
			public void done(ResultSet result, Throwable error) {
				try {
					result.next();
					String value = result.getString("value");
					BadBlockHub hub = BadBlockHub.getInstance();
					Gson gson = hub.getGsonExpose();
					Map<Integer, NPCData> updatedMap = gson.fromJson(value, type);
					Map<Integer, NPCData> oldMap = NPCData.stockage;
					Bukkit.getScheduler().runTask(hub, new Runnable() {
						@Override
						public void run() {
							// New
							for (Entry<Integer, NPCData> npcData : updatedMap.entrySet()) {
								if (!oldMap.containsKey(npcData.getKey())) {
									npcData.getValue().yop();
								}
							}
							// Remove old
							for (Entry<Integer, NPCData> npcData : oldMap.entrySet()) {
								if (!updatedMap.containsKey(npcData.getKey())) {
									npcData.getValue().remove();
								}
							}
						}
					});
					NPCData.stockage = updatedMap;
					result.close(); // don't forget to close it
				}catch(Exception exception) {
					exception.printStackTrace();
				}
			}

		});
	}

}
